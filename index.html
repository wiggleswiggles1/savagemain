<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Fixed TikTok TTS | TechBuilds</title>
    <script src="https://js.pusher.com/8.3.0/pusher.min.js"></script>
    <style>
        body { background: transparent; overflow: hidden; margin: 0; padding: 0; }
        #status-msg { position: fixed; top: 10px; left: 10px; color: white; font-family: sans-serif; font-size: 11px; text-shadow: 1px 1px black; opacity: 0.6; }
    </style>
</head>
<body>
<div id="status-msg">TTS Initializing...</div>

<script>
    // --- CONFIGURATION ---
    const KICK_CHATROOM_ID = "1085080"; 
    const TWITCH_CHANNEL = "xstr8xsavagex";
    const TWITCH_OAUTH = "oauth:k00bellyf4iqcc6obzjomv9c7v6w1q";

    // Your original filters
    const USER_BLACKLIST = ["streamelements", "nightbot", "botrix", "kicktools", "kickbot", "growopgame", "missxss", "botrixoficial", "BotRixOficial"]; 
    const WORD_BLACKLIST = ["http", ".com", ".net", ".org"]; 
    const PREFIX_BLOCK = ["!", "/"]; 

    // Diverse TikTok Voice List
    const TIKTOK_VOICES = [
        "en_us_001", // Jessie
        "en_us_006", // Joey
        "en_us_007", // Professor
        "en_us_009", // Scientist
        "en_us_010", // Confidence
        "en_us_rocket", // Rocket
        "en_us_stormtrooper", // Stormtrooper
        "en_us_ghostface", // Ghostface
        "en_male_funny", // Wacky
        "en_male_narration" // Storyteller
    ];

    let ttsEnabled = true;
    let subOnlyMode = false;
    let readNames = false;
    let lastProcessedMessage = "";

    function updateStatusUI() {
        const el = document.getElementById('status-msg');
        const mode = subOnlyMode ? "SUBS ONLY" : "ALL";
        el.innerText = `TikTok TTS: ${ttsEnabled ? 'ON' : 'OFF'} | Mode: ${mode} | Names: ${readNames ? 'ON' : 'OFF'}`;
        el.style.color = ttsEnabled ? '#53fc18' : '#ff4b4b';
    }

    // --- ENHANCED SPEAKING LOGIC ---
    async function speak(user, text) {
        if (!ttsEnabled) return;

        // 1. Generate unique hash for user
        let hash = 0;
        for (let i = 0; i < user.length; i++) {
            hash = ((hash << 5) - hash) + user.charCodeAt(i);
            hash |= 0;
        }

        // 2. Pick a unique voice
        const voiceIndex = Math.abs(hash) % TIKTOK_VOICES.length;
        const selectedVoice = TIKTOK_VOICES[voiceIndex];

        const phrase = readNames ? `${user} says ${text}` : text;
        const cleanPhrase = phrase.substring(0, 200);

        // 3. New API Request with Cache Buster (t=...) to force voice changes
        const url = `https://tiktok-tts.weilbyte.dev/api/generate?engine=tiktok&voice=${selectedVoice}&text=${encodeURIComponent(cleanPhrase)}&t=${Date.now()}`;

        try {
            const audio = new Audio(url);
            
            // 4. Pitch/Speed Shift Backup
            // Even if the voice sounds similar, we slightly change the speed per user
            const speedShift = 1.0 + ((Math.abs(hash) % 10) / 100); 
            audio.playbackRate = speedShift; 

            await audio.play();
            console.log(`Speaking: ${user} | Voice: ${selectedVoice} | Speed: ${speedShift}`);
        } catch (err) {
            console.error("TikTok API Error, trying Google Fallback:", err);
            const gUrl = `https://translate.google.com/translate_tts?ie=UTF-8&tl=en&client=tw-ob&q=${encodeURIComponent(cleanPhrase)}`;
            new Audio(gUrl).play();
        }
    }

    // --- MESSAGE PROCESSING ---
    function processAndSpeak(user, raw, isMod, isSub, isKick) {
        const lowerUser = user.toLowerCase();
        if (USER_BLACKLIST.includes(lowerUser)) return;
        if (PREFIX_BLOCK.some(p => raw.trim().startsWith(p))) return;
        if (subOnlyMode && !isMod && !isSub) return;
        if (raw === lastProcessedMessage) return; 
        lastProcessedMessage = raw;

        let clean = raw;
        if (isKick) { 
            clean = clean.replace(/\[emote:\d+:[^\]]+\]/g, ''); 
        }
        
        // RegEx: Keep letters, numbers, spaces, ?, !, ., ,, and $
        clean = clean
            .replace(/<[^>]*>?/gm, '')           
            .replace(/:[a-zA-Z0-9_-]+:/g, '')    
            .replace(/\[[^\]]*\]/g, '')          
            .replace(/[^\w\s?.!,\$]/g, '') 
            .replace(/\s+/g, ' ')                
            .trim();

        if (WORD_BLACKLIST.some(word => clean.toLowerCase().includes(word.toLowerCase()))) return;
        if (/[a-zA-Z0-9]/.test(clean) === false) return;

        speak(user, clean);
    }

    // --- COMMANDS ---
    function handleCommands(user, msg, isMod) {
        if (!isMod) return;
        const cmd = msg.toLowerCase().trim();
        if (cmd === "!ttsoff") ttsEnabled = false;
        else if (cmd === "!ttson") ttsEnabled = true;
        else if (cmd === "!subson") subOnlyMode = true;
        else if (cmd === "!subsoff") subOnlyMode = false;
        else if (cmd === "!namesoff") readNames = false;
        else if (cmd === "!nameson") readNames = true;
        updateStatusUI();
    }

    // --- KICK CONNECTION ---
    const pusher = new Pusher('32cbd69e4b950bf97679', { cluster: 'us2', forceTLS: true });
    const kickChannel = pusher.subscribe(`chatrooms.${KICK_CHATROOM_ID}.v2`);
    kickChannel.bind('App\\Events\\ChatMessageEvent', (data) => {
        const chat = typeof data === 'string' ? JSON.parse(data) : data;
        const isMod = chat.sender.identity.badges.some(b => b.type === 'moderator' || b.type === 'broadcaster');
        const isSub = chat.sender.identity.badges.some(b => b.type === 'subscriber' || b.type === 'founder');
        handleCommands(chat.sender.username, chat.content, isMod);
        processAndSpeak(chat.sender.username, chat.content, isMod, isSub, true);
    });

    // --- TWITCH CONNECTION ---
    function connectTwitch() {
        const socket = new WebSocket('wss://irc-ws.chat.twitch.tv:443');
        socket.onopen = () => {
            socket.send(`PASS ${TWITCH_OAUTH}`);
            socket.send(`NICK ${TWITCH_CHANNEL}`);
            socket.send(`JOIN #${TWITCH_CHANNEL}`);
        };
        socket.onmessage = (event) => {
            const raw = event.data;
            if (raw.startsWith('PING')) { socket.send('PONG :tmi.twitch.tv'); return; }
            if (raw.includes('PRIVMSG')) {
                const user = raw.match(/:([^!]+)!/)[1];
                const msgPart = raw.split(' PRIVMSG #' + TWITCH_CHANNEL + ' :');
                if (msgPart.length < 2) return;
                const message = msgPart[1].trim();
                const isMod = raw.includes('mod=1') || raw.includes('broadcaster/1');
                const isSub = raw.includes('subscriber=1');
                handleCommands(user, message, isMod);
                processAndSpeak(user, message, isMod, isSub, false);
            }
        };
        socket.onclose = () => setTimeout(connectTwitch, 5000);
    }

    connectTwitch();
    updateStatusUI();
</script>
</body>
</html>